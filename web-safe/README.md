# [突破前端面试] - Web 安全相关

## 前言

年前年后跳槽季，准备从面试内容入手看看前端相关知识点，旨在探究一个系列知识点，能力范围之内的深入探究一下。重在实践，针对初级前端和准备面试的同学，争取附上实际的代码例子以及相关试题～系列名字就用【秃破前端】—— 因为圈内大家共识，技术与发量成正比。😄希望大家早日 **秃** 破瓶颈～

> 关于面试题或者某个知识点的文章太多了，这里笔者只是想把个人的总结用代码仓库的形式记录下来并输出文章，毕竟理论不等于实践，知其然也要知其所以然，实践用过才能真正理解～

相关系列同类型文章：
 - [秃破前端面试 —— HTTP && HTTPS](https://juejin.im/editor/posts/5dea2504f265da33b201ba0b)
 - [秃破前端面试 —— Web安全相关](https://juejin.im/editor/postss/5df60580518825121f699cd6)
 - [秃破前端面试 —— 跨域实践总结](https://juejin.im/editor/posts/5df3afa76fb9a016266456a7)

## 同源策略

如果两个 url 它们的`协议`、`域名`和`端口`都相同，则他们是同源的。

## XSS(跨站脚本攻击 Cross Site Scripting)

#### 存储型 XSS 攻击

利用漏洞提交恶意的JavaScript代码，比如在`input`和`textare`区域内填写一段脚本代码`<script src="http://恶意网站脚本"></script>`，当用户存储然后再打开预览页面的时候，该段脚本就会执行，然后将用户相关的信息（如cookie等）上传到对方服务器。

#### 反射型 XSS 攻击

用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。 在现实生活中，黑客经常会通过 QQ 群或者邮件等渠道诱导用户去点击这些恶意链接。

#### 预防策略

 - 将cookie等敏感信息设置为`httpOnly`，禁止Javascript通过`document.cookie`获得。

 - 对所有的输入做严格的校验尤其是在服务器端，过滤掉任何不合法的输入，比如手机号必须是数字。

> 也就是一般来说前后端都要做校验，前端校验的是输入合法性，后端校验的是安全性相关。

  -  净化和过滤掉不必要的html标签，比如：`<iframe>`, `alt`, `<script>` ;净化和过滤掉不必要的Javascript的事件标签，比如：`onclick`, `onfocus`等。
  
  -  转义单引号，双引号，尖括号等特殊字符，可以采用html encode编码或者过滤掉这些特殊字符。

## 跨站请求伪造（CRSF Cross Site Request Forgery）

引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。
发起 CSRF 攻击的三个必要条件：

 - 目标站点一定要有 CSRF 漏洞；
 - 用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；
 - 需要用户打开一个第三方站点，如黑客的站点等。

> CRSF的要求比较多，但是如果被攻击也比较致命。

  比如，在出现CSRF漏洞的博客网站，`http://blog.com?postId=111&delete=1`表示删除`id=111`的用户文章，当然这个条件是用户在该网站已经登录，然后攻击者新建一个页面，页面内容是一个图片`<img src='http://blog.com?postId=111&delete=1' />`。当该用户打开页面的时候，就执行了这个删除操作，防不胜防。还有更致命的就是银行账户转账的操作。
  
### 预防策略

#### 利用好Cookie的`SameSite`属性

SameSite 选项通常有 Strict、Lax 和 None 三个值。

 - SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。
 
 - Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。
 
 - 如果使用 None 的话，在任何情况下都会发送 Cookie 数据
  

#### 验证请求的来源

如果是敏感请求，可以判断一下请求的`Origin`和`Referer`。Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址，而O rigin 属性只包含了域名信息，并没有包含具体的 URL 路径。这是 Origin 和 Referer 的一个主要区别。
服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。

#### 使用token验证

所有请求的身份信息判断使用token来验证。

## 点击劫持

 - 诱使用户点击看似无害的按钮（实则点击了透明 iframe 中的按钮）.
 - 监听鼠标移动事件，让危险按钮始终在鼠标下方.
 - 使用 HTML5 拖拽技术执行敏感操作（例如 deploy key）.

#### 预防策略：

 - 服务端添加 X-Frame-Options 响应头,这个 HTTP 响应头是为了防御用 iframe 嵌套的点击劫持攻击。 这样浏览器就会阻止嵌入网页的渲染。
 - JS 判断顶层视口的域名是不是和本页面的域名一致，不一致则不允许操作，`top.location.hostname === self.location.hostname`；
 - 敏感操作使用更复杂的步骤（验证码、输入项目名称以删除）。

## window.opener 安全问题

window.opener 表示打开当前窗体页面的的父窗体的是谁。例如，在 A 页面中，通过一个带有 target="_blank" 的 a 标签打开了一个新的页面 B，那么在 B 页面里，window.opener 的值为 A 页面的 window 对象。
一般来说，打开同源(域名相同)的页面，不会有什么问题。但对于跨域的外部链接来说，存在一个被钓鱼的风险。比如你正在浏览购物网站，从当前网页打开了某个外部链接，在打开的外部页面，可以通过 window.opener.location 改写来源站点的地址。利用这一点，将来源站点改写到钓鱼站点页面上，例如跳转到伪造的高仿购物页面，当再回到购物页面的时候，是很难发现购物网站的地址已经被修改了的，这个时候你的账号就存在被钓鱼的可能了。
预防策略：

#### 解决办法设置 rel 属性
```
<a href="https://xxxx" rel="noopener noreferrer"> 外链 <a>
```
 - `rel="noopener noreferrer"` 规定禁止新页面传递源页面的地址，通过设置了此属性的链接打开的页面，其 window.opener 的值为 null。
 

 - 将外链替换为内部的跳转连接服务，跳转时先跳到内部地址，再由服务器 redirect 到外链。
 

 - 可以由`widow.open`打开外链。

## 相关题目

#### 1. 什么是 XSS 攻击？

#### 2. 什么是 CSRF 攻击？

#### 3. 如何预防前端攻击？

